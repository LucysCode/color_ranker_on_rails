<h1 style="text-align:center">Welcome to Color Ranker. You can rank ugly colors!</h1>
<h2 style="text-align:center">Is this color ugly?</h2>
<p style="text-align:center">Select up to <%= @max_colors %> ugly colors and <%= @max_colors %> great colors!</p>

<!-- Middle: Ugly | Color Box | Nice -->
<div style="display: flex; justify-content: center;">

  <!-- Left Column: Ugly Colors -->
  <!-- The flex: 1; tells the element how much space it should take up relative to its siblings inside a flex container. Pulls from application.css-->
  <div id="ugly_colors" class="sortable-list" style="flex: 1;">
    <!-- When someone votes a color as ugly, Top Ugly Colors show up. Otherwise, it's hidden. -->
    <% if @ugly_colors.present? %>
      <h3>Top Ugly Colors</h3>
      <!-- <ul> stands for unordered list. An HTML element used to group a list of items where order doesn't matter (i.e., no numbering). Inside a <ul>, you typically use <li> elements. <ul> auto adds bullet points and denting. The style removes the bullet points and denting. -->
      <!-- The id is defined here, basically a label. The functionality is written in javascript block. -->
      <ul id="ugly_colors_list" style="list-style-type:none; padding: 0;">

        <!-- This pulls from home_controller.rb, where @ugly_colors is an array of colors that has 'is_ugly' set to 'true'. -->
        <!-- .take Ruby method limits the number of @ugly_colors to the value of @max_colors. Taking into account the ordering defined by @ugly_colors in home_controller.rb. -->
        <!-- .each do |color_vote| is a loop. color_vote represents the element in the @ugly_colors array. The following code loops through color_vote element of @ugly_colors. -->
        <% @ugly_colors.take(@max_colors).each do |color_vote| %>
          <!-- <li> is a list that's usually in <ul>. -->
          <!-- data-id is a data attribute. And color_vote.id is the ID # that identifies which color_vote it is, as votes come in. -->
          <li data-id="<%= color_vote.id %>" style="margin: 10px 0; cursor: grab; display: flex; justify-content: center;">
            <div class="side-color-box" style= "background-color: <%= color_vote.hex_color %>;"></div>
            <!-- <span> is an inline HTML element used to group and style small chunks of text or content without affecting the layout structure. Rank is hard-coded. -->
            <!-- color_vote.position starts at 0 so to let users see the ranking start at 1, add +1 to color_vote.position. -->
            <span style="font-weight: bold;">&nbsp;Rank:&nbsp;</span>
            <span class="position-number" style="font-weight: normal;"><%= color_vote.position.to_i + 1 %></span>
          </li>
        <% end %>
    
      </ul>
    <% end %>
  </div>


  <!-- Center Column: Color Box and Buttons -->
  <div style="flex: 1; text-align: center;">

    <!-- Logic to show the color box, unless the meme shows up. -->
    <% unless @show_pikachu %>
      <form method="get" action="<%= root_path %>">
        <input type="hidden" name="new_color" value="true" />
          <button type="submit" style="border: none; background: none; padding: 0; margin: 0px; cursor: pointer;">
            <div class="main-color-box" style="background-color: <%= @hex_color %>;"></div>
            <p>Hex Code: <%= @hex_color %></p>
          </button>  
      </form>  
    <% end %>

    <!-- Styling for meme -->
    <% if @show_pikachu %>
      <div style="text-align: center;">
        <img src="<%= @image_url %>" alt="Surprised Pikachu" class="meme-box" />
        <small style="font-size: 6px;">
          Image from
          <a href="https://knowyourmeme.com/memes/surprised-pikachu" target="_blank" rel="noopener noreferrer">
            Know Your Meme
          </a>
        </small>
        <p>Pikachu: I&rsquo;m surprised</p>
      </div>
    <% end %>

    <!-- Buttons to vote -->
    <div style="display: flex; justify-content: center; gap: 12px; max-width: 400px; margin: 0 auto;">
      <div style="flex: 1;">
        <button style="width: 100%;" onclick="submitVote('ugly')">
          Ew, it&rsquo;s ugly
        </button>
      </div>
      <div style="flex: 1;">
        <button style="width: 100%;" onclick="submitVote('nice')">
          Great color
        </button>
      </div>
    </div>

    <!-- Button to generate new color only -->
    <div>
      <form method="get" action="/">
        <input type="hidden" name="new_color" value="true">
        <button type="submit">Not sure, give me a new color</button>
      </form>
    </div>

    <!-- Reset button for votes -->
    <div style="display: flex; justify-content: center; gap: 12px; max-width: 400px; margin: 0 auto;">
      <form method="post" action="<%= reset_ugly_path %>" style="flex: 1;">
        <%= hidden_field_tag :authenticity_token, form_authenticity_token %>
        <button type="submit" style="width: 100%;">Reset Ugly Only</button>
      </form>

      <form method="post" action="<%= reset_nice_path %>" style="flex: 1;">
        <%= hidden_field_tag :authenticity_token, form_authenticity_token %>
        <button type="submit" style="width: 100%;">Reset Nice Only</button>
      </form>
    </div>

    <div>
      <form method="post" action="/reset">
        <!-- Adds hidden input field that includes CSRF protection token. Required for "post" methods. -->
        <!-- Analogy: Mailing an envelope. Write stuff (inputs), seal it with stamp (token), drop it mailbox (submit), goes to address (action), handled by someone (controller). -->
        <%= hidden_field_tag :authenticity_token, form_authenticity_token %>
        <button type="submit">Reset</button>
      </form>
    </div>

    <!-- Route to Color Pairs page -->
    <div style="margin: 69px;">
      <%= link_to "Color Pairs Ranker", rank_color_pairs_path %>
    </div>
    
    <!-- Message for max votes, dependent on which vote is maxed. -->
    <% if @message %>
      <p style="color: red;"><%= @message %></p>
    <% end %>

    <!-- Message for when the reset button is clicked. -->

    <% if flash[:notice] %>
      <div id="flash-notice" class="flash-message" style="color: red">
        <%= flash[:notice] %>
      </div>
    <% end %>


  </div>

  <!-- Right Column: Nice Colors -->
  <div id="nice_colors" class="sortable-list" style="flex: 1;">
    <% if @nice_colors.present? %>
      <h3>Top Nice Colors</h3>
      <ul id="nice_colors_list" style="list-style-type:none; padding: 0;">

        <% @nice_colors.take(@max_colors).each do |color_vote| %>
          <li data-id="<%= color_vote.id %>" style="margin: 10px 0; cursor: grab; display: flex; justify-content: center;">
            <div class="side-color-box" style= "background-color: <%= color_vote.hex_color %>;"></div>
            <span style="font-weight: bold;">&nbsp;Rank:&nbsp;</span>
            <span class="position-number" style="font-weight: normal;"><%= color_vote.position.to_i + 1 %></span>
          </li>
        <% end %>
      
      </ul>
    <% end %>
  </div>


<!-- This is javascript. Use Javascript syntax. -->
<script>

// This creates a function called submitVote and takes in one parameter called 'vote'. In this case, vote is either 'ugly' or 'nice'
function submitVote(vote) {
  // A function that makes network requests. /vote is the route URL being called.
  fetch('/vote', { // Code between here and the next closing bracket is where you configure the request. Basically saying, 'send a request to /vote with this configuration.
    // 'POST' means I'm submitting data to the server. vs 'GET' which retrieves read-only data.
    method: 'POST',
    headers: {
      // Content-Type tells the server 'I'm sending JSON (JavaScript Object Notation) data in the body of this request, otherwise server wouldn't know how to parse the incoming data. 
      'Content-Type': 'application/json',
      // Token protects against CSRF attacks. This token is what Rails expects for Javascript.
      'X-CSRF-Token': '<%= form_authenticity_token %>'
    },
    // This is the actual data I'm sending to the POST request. vote: vote turns into vote: "ugly" for example.
    body: JSON.stringify({ vote: vote })
    // Promise Handler. Runs once the server sends back a response. Response is the reply from /vote URL endpoint
  }).then(response => {
    // response.ok checks to see if server said "Success!"
    if (response.ok) {
      // If the response is 'success', redirect page to / end point with ?new_color=true params.
      // Does this trigger Rails app to show a new color on page load?
      window.location.href = "/?new_color=true";
      // If response fails, show the alert to the user.
    } else {
      alert("Failed to submit vote.");
    }
  });
}

// Once the page is ready, run the code inside this function (before images or stylesheets finish loading). This prevents errors if JavaScript tries to work with HTML elements that havenâ€™t been loaded yet.
document.addEventListener("DOMContentLoaded", function () {
  // Checks for elemeent ugly_colors_list on the page
  if (document.getElementById('ugly_colors_list')) {
    // Enables drag and drop sorting of lists. This is a new sortable list instance connecting to the DOM element with the ID ugly_colors_list
    new Sortable(document.getElementById('ugly_colors_list'), {
      // This groups the sortable list to the group named 'ugly'. AKA this is part of the 'ugly' group.
      group: 'ugly',
      // Defines an event handler. Code that runs when the drag ends and the item (color) is dropped.
      onEnd: function(evt) {
        // This calls the function updatePosition Javascript further down in the code. 
        // It passes the list name (ugly_colors_list), the new position (evt.newIndex), and the original position (evt.oldIndex). AKA a color moved, update the database to reflect its new position. 
        updatePosition('ugly_colors_list', evt.newIndex, evt.oldIndex);
      }
    });
  }

  if (document.getElementById('nice_colors_list')) {
    new Sortable(document.getElementById('nice_colors_list'), {
      group: 'nice',
      onEnd: function(evt) {
        updatePosition('nice_colors_list', evt.newIndex, evt.oldIndex);
      }
    });
  }
});

// This function takes in 3 parameters: listId (id of HTML list being updated), newIndex (new position of item moved), oldIndex (old position of item).
function updatePosition(listId, newIndex, oldIndex) {
  // Finds the HTML list (ul) on the page by its ID and saves it to the list variable. Line 107 for example.
  const list = document.getElementById(listId);
  // Create an array (orderedIds) by converting all <li> elements inside list into an array, then mapping each li to its data-id value.
  const orderedIds = Array.from(list.querySelectorAll('li')).map((li) => li.dataset.id);

  // Update the order on the server
  // Sends a POST request to your Rails server at /update_position.
  fetch('/update_position', {
    // Same as block of code from function submitVote
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRF-Token': '<%= form_authenticity_token %>'
    },
    // Data I'm sending
    body: JSON.stringify({
      ordered_ids: orderedIds, // An array of color vote ids (in new order)
      list_type: listId // Which list it came from: ugly_colors_list, or nice_colors_list
    })
    // When the server responds do the following block of code
  }).then(response => {
    // If the server response is successful
    if (response.ok) {
      // Once the order is updated successfully, update the position number on the frontend
      // Gets all the current list items again
      const items = list.querySelectorAll('li');
      // Loops through each item and updates its visible number
      items.forEach((item, index) => {
        // It finds the span or element with class .position-number inside each item and updates its content to match the new position
        item.querySelector('.position-number').textContent = index + 1; // Update the position number on the frontend
      });
    } else {
      alert('Failed to update order');
    }
  });
}

// Timer for notice and messages
  document.addEventListener("turbo:load", () => {
    const notice = document.getElementById("flash-notice");
    if (notice) {
      setTimeout(() => {
        notice.style.transition = "opacity 1s ease";
        notice.style.opacity = "0";
        setTimeout(() => notice.remove(), 1000);
      }, 3000);
    }
  });

</script>

<!-- This is Sortable.js library to allow for drag-and-drop functionality -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>
